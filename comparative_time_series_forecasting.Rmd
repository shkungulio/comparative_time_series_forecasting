---
title: |
  \vspace*{\fill}
  \fontsize{36}{40}\selectfont \textbf {Comparative Time Series Forecasting of Major Technology Stocks}
author: |
  \fontsize{24}{28}\selectfont Seif H. Kungulio
date: |
  \fontsize{18}{22}\selectfont January 22, 2026
  \ \vspace*{\fill}
output: 
  pdf_document:
    latex_engine: xelatex
    toc: false
    highlight: espresso
    include:
      in_header: resources/header.tex
header-includes:
  # Font and color setup
  - \usepackage{xcolor}
  - \definecolor{brand}{HTML}{8B0000}
  - \definecolor{subbrand}{HTML}{212121}
  - \usepackage{titlesec}
  - \titleformat{\section}{\Large\bfseries\color{brand}}{\thesection}{1em}{}
  - \titleformat{\subsection}{\large\bfseries\color{subbrand}}{\thesubsection}{0.75em}{}
  - \usepackage[most]{tcolorbox}
  - \tcbset{colback=white, colframe=brand, coltitle=white, fonttitle=\bfseries}
  - \usepackage{fancyhdr}
  - \pagestyle{fancy}
  - \fancyhead[L]{\textcolor{brand}{Comparative Time Series Forecasting (AAPL, MSFT, TSLA, AMZN)}}
  - \fancyhead[R]{\textcolor{subbrand}{Seif H. Kungulio}}
  - \fancyfoot[C]{\thepage}
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width=14, fig.height=8)

# Set default CRAN mirror
options(repos = c(CRAN = "https://cloud.r-project.org"))

#Install the following libraries if required
# List of required packages
required_pkgs <- c("tidyverse", "lubridate", "forecast", "tseries", 
                   "quantmod", "xts", "zoo", "PerformanceAnalytics") 

# Install and load each package
for (pkg in required_pkgs) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg)
  }
  library(pkg, character.only = TRUE)
}

theme_set(theme_test(base_size = 14))
options(dplyr.summarise.inform = FALSE)
```

\pagenumbering{gobble}

\newpage
\thispagestyle{plain}
&nbsp;

\newpage
\pagenumbering{roman}
\tableofcontents

\newpage
\pagenumbering{arabic}


# **Business Understanding**
## Problem Statement
Historical stock prices of major technology companies exhibit distinct trends, volatility patterns, and market dynamics. Understanding these behaviors is essential for forecasting price movements and assessing financial risk.

The objective of this project is to perform a comparative time series analysis of Apple, Microsoft, Tesla, and Amazon stock prices using historical market data. The project aims to identify trends, seasonality, and volatility across each stock and develop forecasting models to predict short-term price movements. Model performance will be evaluated to assess forecasting accuracy and differences in predictability across companies.

## Business Objectives
* Compare trend, seasonality, and volatility across AAPL, MSFT, TSLA, and AMZN.
* Forecast short-term price movements using multiple models.
* Evaluate models using time-series appropriate validation and accuracy metrics.
* Rank stocks by forecastability (which stock is easier/harder to predict).

## Success Criteria
* Clean daily dataset per stock with aligned calendars.
* Baseline model + at least one statistical forecasting model per stock.
* Residual diagnostics + accuracy metrics (RMSE/MAE/MAPE).
* Clear comparative summary and recommendation.


\newpage
# **Data Understanding**
## Data Source
Historical stock price data for Apple (AAPL), Microsoft (MSFT), Tesla (TSLA), and Amazon (AMZN) will be sourced from Yahoo Finance using the `quantmod` package in R. The dataset will include daily adjusted closing prices, volume, and other relevant financial metrics from January 1, 2016, to current date.

## Stock Tickers
* Apple Inc. (AAPL)
* Microsoft Corporation (MSFT)
* Tesla, Inc. (TSLA)
* Amazon.com, Inc. (AMZN)

```{r data-fetching}
# Define stock tickers and date range
tickers <- c("AAPL", "MSFT", "TSLA", "AMZN")
start_date <- as.Date("2016-01-01")
end_date <- as.Date("2026-01-20")
```

Here we define the study universe (AAPL, MSFT, TSLA, AMZN) and the historical window (**2016-01-01 to 2026-01-20**). The study period is fixed from January 1, 2016 to January 20, 2026 to ensure consistent temporal coverage across all securities. Using a common observation window allows differences in trends, volatility, and forecast accuracy to be attributed to underlying stock behavior rather than discrepancies in data availability or sampling periods.

## Pull Historical Prices
```{r data-pulling}
prices_list <- map(
  tickers,
  ~ getSymbols(
    .x,
    src = "yahoo",
    from = start_date,
    to = end_date,
    auto.assign = FALSE
  )
)
names(prices_list) <- tickers

# Preview data
map(prices_list, head)
map(prices_list, tail)
```

This chunk retrieves daily OHLCV data from Yahoo Finance into a named list of `xts` objects—one per ticker. Inspecting the `head()`/`tail()` snapshots is a quick sanity check that:

1. dates are ordered correctly
2. Fields exist as expected (Open/High/Low/Close/Volume/Adjusted)
3. Price scales differ substantially across tickers—reinforcing why later we use **indexing (start=100)** and **returns** for apples-to-apples comparison.

## Extract Adjusted Close Prices
```{r adjusted-close}
close_list <- map(prices_list, ~ Cl(.x))
names(close_list) <- tickers

# Combine into a single xts with aligned dates
close_xts <- do.call(merge, close_list)
colnames(close_xts) <- tickers

head(close_xts)
tail(close_xts)
```

Adjusted closing prices are extracted for each ticker and merged into a single aligned `xts` object. This structure enables consistent downstream computation of returns, rolling statistics, and forecasting models. The merged dataset confirms that all series share the same trading calendar and exhibit strong upward trends over the analysis horizon, indicating non-stationarity in price levels.

## Missing Dates / Alignment
Markets close on weekends/holidays; we keep the market calendar as-is.
```{r missing-dates}
close_xts_aligned <- na.omit(close_xts)
dim(close_xts); dim(close_xts_aligned)
```

Financial markets operate on an irregular calendar due to weekends and holidays. After merging all series, `na.omit()` is applied to retain only dates where all tickers are simultaneously observed. Since the dimensionality remains unchanged, the merged dataset contains a complete intersection of trading days with no missing values across assets.


\newpage
# **Data Preparation**
## Convert to Tidy Data
```{r tidy-data}
close_df <- close_xts_aligned %>%
  fortify.zoo() %>%
  as_tibble() %>%
  rename(date = Index) %>%
  pivot_longer(-date, names_to = "ticker", values_to = "close")

glimpse(close_df)
```

The wide `xts` object is reshaped into a long, tidy format with one observation per date and ticker. This structure facilitates grouped transformations, visualization, and comparative analysis using `ggplot2` and `tidyverse` workflows. The resulting dataset contains **10,100** observations corresponding to **2,525** trading days across four securities.

## Create Returns (Risk/Volatility Lens)
Returns analysis is essential for risk assessment.
```{r returns-calculation}
returns_xts <- na.omit(Return.calculate(close_xts_aligned, method = "log"))
colnames(returns_xts) <- tickers

returns_df <- returns_xts %>%
  fortify.zoo() %>%
  as_tibble() %>%
  rename(date = Index) %>%
  pivot_longer(-date, names_to = "ticker", values_to = "log_return")

summary(returns_df$log_return)
```

Daily log returns are computed to transform non-stationary price series into a scale-free representation suitable for volatility and risk analysis. The empirical return distribution exhibits heavy tails, with occasional extreme positive and negative values. Such behavior is consistent with financial time series and motivates the use of rolling volatility measures and robust forecasting benchmarks.


\newpage
# **Exploratory Data Analysis (EDA)**
## Price Trends
```{r price-trends}
close_df %>%
  ggplot(aes(date, close, color = ticker)) +
  geom_line() +
  labs(
    title = "Closing Prices Over Time (AAPL, MSFT, TSLA, AMZN)",
    x = "Date", y = "Close Price (USD)"
  )
```

The time series of closing prices illustrates long-term growth patterns and major structural shifts across all securities. Absolute price levels differ substantially between tickers, limiting direct comparability. This visualization primarily supports individual trend inspection rather than relative performance analysis.

## Normalize Prices (Indexed to 100)
```{r normalized-prices}
close_indexed <- close_df %>%
  group_by(ticker) %>%
  arrange(date) %>%
  mutate(index_100 = 100 * close / first(close)) %>%
  ungroup()

close_indexed %>%
  ggplot(aes(date, index_100, color = ticker)) +
  geom_line() +
  labs(
    title = "Indexed Closing Prices (Start = 100)",
    x = "Date", y = "Index"
  )
```

Price series are indexed to a common baseline value of **100** at the first observation for each ticker. This transformation standardizes scale and enables direct comparison of relative growth trajectories. The indexed series highlight substantial divergence in cumulative performance across stocks over the study period.

## Return & Drawdown Summary
```{r returns-drawdown}
charts.PerformanceSummary(
  returns_xts,
  main = "Performance Summary: Daily Log Returns (All Stocks)")
```

The performance summary visualizes cumulative returns, daily return distributions, and drawdowns in a unified framework. This representation captures both long-term compounding behavior and short-term risk characteristics. Differences in drawdown depth and return variability reflect heterogeneity in volatility regimes across securities.

## Volatility Comparison (Rolling Std. Dev.)
```{r volatility-comparison}
roll_n <- 20 # ~1 trading month
roll_vol <- rollapply(returns_xts, 
                      width = roll_n, 
                      FUN = sd, 
                      by.column = TRUE, 
                      align = "right", 
                      fill = NA) %>%
  na.omit()

roll_vol_df <- roll_vol %>%
  fortify.zoo() %>%
  as_tibble() %>%
  rename(date = Index) %>%
  pivot_longer(-date, 
               names_to = "ticker", 
               values_to = "roll_sd")

roll_vol_df %>%
  ggplot(aes(date, roll_sd, color = ticker)) +
  geom_line() +
  labs(
    title = glue::glue("Rolling Volatility (Std Dev of Returns) - {roll_n} Trading Days"),
    x = "Date", 
    y = "Rolling SD"
  )
```

Rolling 20-day standard deviations of log returns are computed as a proxy for monthly realized volatility. The resulting series display volatility clustering, a common characteristic of equity markets. Higher and more frequent volatility spikes indicate increased uncertainty and reduced short-horizon predictability for certain securities.

## Decomposition (Monthly Aggregation)
Classic decomposition is easiest on regular seasonal frequency. Converted daily close to monthly close and decompose per stock.

```{r decomposition}
monthly_close_list <- map(close_list, ~ Cl(to.monthly(.x)) )
names(monthly_close_list) <- tickers

decomp_plots <- function(x_xts, ticker_name){
  ts_obj <- ts(
    as.numeric(x_xts), 
    frequency = 12,
    start = c(year(start(x_xts)), month(start(x_xts)))
    )
  dc <- decompose(ts_obj)
  plot(dc)
  title(main = paste("Decomposition:", ticker_name),
        outer = TRUE, line = -1)
  invisible(dc)
}

# Decompose each ticker (plots)
decomps <- imap(monthly_close_list, ~ decomp_plots(.x, .y))
```

Daily closing prices are aggregated to monthly frequency to facilitate classical additive decomposition. Across all securities, the trend component dominates the series, while seasonal effects are comparatively weak and unstable. The remainder component captures irregular fluctuations associated with firm-specific and macroeconomic events. These results suggest that forecasting models should prioritize trend handling rather than fixed seasonal structure.


\newpage
# **Modeling**
## Forecasting Design
The focus of forecasting design is short-term movement using:

* Naive baseline (last value persists) - strong baseline in finance.
* ARIMA (auto.arima) - standard statistical model for time series. 

I’ll do a rolling-origin evaluation (time-series CV) AND a simple holdout for interpretability.

## Helper Functions
```{r helper-functions}
make_train_test <- function(x, h = 60){
  # x is a numeric vector or ts; h is forecast horizon
  n <- length(x)
  list(train = x[1:(n-h)], test = x[(n-h+1):n], h = h)
}

rmse <- function(actual, pred){
  sqrt(mean((actual - pred)^2, na.rm = TRUE))
}

mae <- function(actual, pred){
  mean(abs(actual - pred), na.rm = TRUE)
}

mape <- function(actual, pred){
  mean(abs((actual - pred) / actual), na.rm = TRUE) * 100
}
```

Short-term forecasting is conducted using two benchmark approaches: a naive persistence model and an automatically selected ARIMA model. Model performance is evaluated using a fixed holdout horizon and time-series-appropriate error metrics. This design ensures consistent and comparable evaluation across all securities.

## Build Models per Stock
```{r modeling}
h <- 60  # forecast horizon ~ 3 months of trading days

results <- map_dfr(tickers, function(tk){
  x <- as.numeric(close_xts_aligned[, tk])
  spl <- make_train_test(x, h = h)
  train <- spl$train
  test  <- spl$test
  
  # --- Naive baseline ---
  fc_naive <- naive(train, h = h)
  pred_naive <- as.numeric(fc_naive$mean)
  
  # --- ARIMA ---
  fit_arima <- auto.arima(train)
  fc_arima <- forecast(fit_arima, h = h)
  pred_arima <- as.numeric(fc_arima$mean)
  
  tibble(
    ticker = tk,
    model  = c("Naive", "ARIMA"),
    RMSE   = c(rmse(test, pred_naive), rmse(test, pred_arima)),
    MAE    = c(mae(test, pred_naive),  mae(test, pred_arima)),
    MAPE   = c(mape(test, pred_naive), mape(test, pred_arima))
  )
})

results %>% arrange(ticker, RMSE)
```

Forecast accuracy varies by security and model. For some assets, ARIMA models achieve lower error metrics relative to the naive baseline, indicating the presence of short-term structure beyond random walk behavior. For others, the naive model performs comparably or better, suggesting limited exploitable structure in the evaluation window.

## Visualize Forecasts vs Actuals per Stock
```{r forecast-visualization}
plot_forecast <- function(tk){
  x <- as.numeric(close_xts_aligned[, tk])
  spl <- make_train_test(x, h = h)
  train <- spl$train
  test  <- spl$test
  
  fc_naive <- naive(train, h = h)
  fit_arima <- auto.arima(train)
  fc_arima <- forecast(fit_arima, h = h)
  
  # Plot ARIMA by default; overlay actual test
  autoplot(fc_arima) +
    autolayer(ts(test, start = length(train) + 1), 
              series = "Actual (Test)") +
    labs(title = paste("ARIMA Forecast vs Actual:", tk), 
         x = "Time Index", y = "Close") 
}

walk(tickers, ~ print(plot_forecast(.x)))
```

Forecast-versus-actual plots provide a visual assessment of model performance over the holdout period. Deviations between predicted and observed values highlight challenges associated with abrupt price movements and regime shifts. These plots complement numerical accuracy metrics by illustrating dynamic tracking behavior.


\newpage
# **Evaluation**
## Accuracy Leaderboard (Model Comparison)
Forecast Accuracy by Stock and Model (Lower RMSE/MAE/MAPE is Better)
```{r accuracy-leaderboard}
results %>%
  group_by(ticker) %>%
  arrange(RMSE, .by_group = TRUE) %>%
  mutate(rank = row_number()) %>%
  ungroup() %>%
  arrange(ticker, rank) %>%
  knitr::kable(digits = 3, 
               caption = "Forecast Accuracy by Stock and Model")
```

This chunk ranks models within each ticker by RMSE and presents a concise leaderboard. Interpreting it: (1) **model selection is ticker-specific** (no single winner across all stocks), and (2) the naive baseline remains a high bar—any alternative model must consistently beat it to justify deployment. This table is also portfolio-friendly because it demonstrates principled evaluation rather than “model shopping.”

## Best Model per Stock
```{r best-models}
best_by_stock <- results %>%
  group_by(ticker) %>%
  slice_min(RMSE, n = 1, with_ties = FALSE) %>%
  ungroup()

best_by_stock %>% knitr::kable(digits = 3, 
                               caption = "Best Model Per Stock (by RMSE)")
```

Selecting the best model per stock (by RMSE) yields: **AAPL → ARIMA**, **AMZN → ARIMA**, **MSFT → Naive**, **TSLA → Naive**. This is an important conclusion for stakeholders: for some assets, simplicity wins. It also supports the project’s comparative goal—identifying which stocks are more forecastable under the same design.

## Residual Diagnostics for Best Models
We check residuals to see if assumptions look reasonable (ACF, histogram, Ljung-Box)
```{r residual-diagnostics}
check_best_residuals <- function(tk){
  x <- as.numeric(close_xts_aligned[, tk])
  spl <- make_train_test(x, h = h)
  train <- spl$train
  
  fit_arima <- auto.arima(train)
  fc_arima <- forecast(fit_arima, h = h)
  
  cat("\n\n### Residual checks for", tk, "\n")
  print(fit_arima)
  checkresiduals(fc_arima)
}

walk(best_by_stock$ticker, check_best_residuals)
```

Residual diagnostics evaluate whether systematic structure remains unexplained by the selected models. Autocorrelation patterns and Ljung–Box test results indicate that residuals for some securities deviate from white noise assumptions. This suggests potential benefits from alternative model classes or extensions incorporating additional dynamics.

## Comparative Interpretation
Comparative Forecastability (Lower RMSE = More Predictable)
```{r comparative-interpretation}
# Stock that is easiest/hardest to forecast (based on best RMSE)
forecastability_tbl <- best_by_stock %>%
  arrange(RMSE) %>%
  mutate(forecastability_rank = row_number())

forecastability_tbl %>%
  knitr::kable(digits = 3, 
               caption = "Comparative Forecastability of Stocks")
```

Securities are ranked by minimum out-of-sample RMSE as a proxy for forecastability. Lower error values indicate more stable short-horizon dynamics under the evaluated modeling framework. The resulting ranking highlights heterogeneity in predictability across technology stocks.


\newpage
# **Deployment**
## Reproducible Forecast Function
A simple deployment-ready function that can be reused in a script, Shiny app, or scheduled job.
```{r deploy-function}
forecast_stock <- function(ticker, from = start_date, to = end_date, h = 20){
  x <- getSymbols(ticker, src = "yahoo", from = from, to = to, auto.assign = FALSE)
  close <- as.numeric(Cl(x))
  
  fit <- auto.arima(close)
  fc  <- forecast(fit, h = h)
  
  list(
    ticker = ticker,
    model  = fit,
    forecast = fc
  )
}

# Example:
demo <- forecast_stock("AAPL", from = start_date, to = end_date, h = 20)
autoplot(demo$forecast) + labs(title = "Deployment Demo: AAPL 20-Day Forecast")
```

The forecasting workflow is encapsulated in a reusable function that retrieves recent market data, fits an ARIMA model, and generates short-term forecasts. This modular structure supports integration into dashboards, scheduled pipelines, or interactive applications, subject to appropriate production safeguards.


\newpage
# **Conclusion**
## Key Findings
The analysis demonstrates meaningful differences in trend behavior, volatility regimes, and forecast accuracy across major technology stocks. Model effectiveness is asset-specific, and simple baselines remain competitive in several cases.

## Next Improvement
Future work may incorporate alternative model families, exogenous predictors, extended forecast horizons, and automated deployment pipelines to enhance predictive performance and operational usability.


\newpage
# **References**
* Hyndman, R. J., & Athanasopoulos, G. (2018). *Forecasting: principles and practice*. OTexts.
* Yahoo Finance. (n.d.). Retrieved from https://finance.yahoo.com/
* R Documentation for `quantmod`, `forecast`, and `tseries` packages.
* Wickham, H., et al. (2019). *Welcome to the tidyverse*. Journal of Open Source Software, 4(43), 1686.
* Brockwell, P. J., & Davis, R. A. (2016). *Introduction to time series and forecasting*. Springer.
* Chatfield, C. (2003). *The analysis of time series: an introduction*. CRC press.
* Box, G. E., Jenkins, G. M., Reinsel, G. C., & Ljung, G. M. (2015). *Time series analysis: forecasting and control*. John Wiley & Sons.
* Tsay, R. S. (2010). *Analysis of financial time series*. John Wiley & Sons.
* Shumway, R. H., & Stoffer, D. S. (2017). *Time series analysis and its applications: with R examples*. Springer.
* ChatGPT (2024). *Assistance with R programming and time series analysis*.


\newpage
\thispagestyle{plain}
\vspace*{\fill}
\begin{center}
\textbf{\Huge Thank You!}
\end{center}
\vspace*{\fill}
