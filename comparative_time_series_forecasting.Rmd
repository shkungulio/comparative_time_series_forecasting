---
title: |
  \vspace*{\fill}
  \fontsize{36}{40}\selectfont \textbf {Comparative Time Series Forecasting of Major Technology Stocks}
author: |
  \fontsize{24}{28}\selectfont Seif H. Kungulio
date: |
  \fontsize{18}{22}\selectfont January 22, 2026
  \ \vspace*{\fill}
output: 
  pdf_document:
    latex_engine: xelatex
    toc: false
    highlight: espresso
    include:
      in_header: resources/header.tex
header-includes:
  # Font and color setup
  - \usepackage{xcolor}
  - \definecolor{brand}{HTML}{8B0000}
  - \definecolor{subbrand}{HTML}{212121}
  - \usepackage{titlesec}
  - \titleformat{\section}{\Large\bfseries\color{brand}}{\thesection}{1em}{}
  - \titleformat{\subsection}{\large\bfseries\color{subbrand}}{\thesubsection}{0.75em}{}
  - \usepackage[most]{tcolorbox}
  - \tcbset{colback=white, colframe=brand, coltitle=white, fonttitle=\bfseries}
  - \usepackage{fancyhdr}
  - \pagestyle{fancy}
  - \fancyhead[L]{\textcolor{brand}{Comparative Time Series Forecasting (AAPL, MSFT, TSLA, AMZN)}}
  - \fancyhead[R]{\textcolor{subbrand}{Seif H. Kungulio}}
  - \fancyfoot[C]{\thepage}
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width=14, fig.height=8)

# Set default CRAN mirror
options(repos = c(CRAN = "https://cloud.r-project.org"))

#Install the following libraries if required
# List of required packages
required_pkgs <- c("tidyverse", "lubridate", "forecast", "tseries", 
                   "quantmod", "xts", "zoo", "PerformanceAnalytics") 

# Install and load each package
for (pkg in required_pkgs) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg)
  }
  library(pkg, character.only = TRUE)
}

theme_set(theme_test(base_size = 14))
options(dplyr.summarise.inform = FALSE)
```

\pagenumbering{gobble}

\newpage
\thispagestyle{plain}
&nbsp;

\newpage
\pagenumbering{roman}
\tableofcontents

\newpage
\pagenumbering{arabic}


# **Business Understanding**
## Problem Statement
Historical stock prices of major technology companies exhibit distinct trends, volatility patterns, and market dynamics. Understanding these behaviors is essential for forecasting price movements and assessing financial risk.

The objective of this project is to perform a comparative time series analysis of Apple, Microsoft, Tesla, and Amazon stock prices using historical market data. The project aims to identify trends, seasonality, and volatility across each stock and develop forecasting models to predict short-term price movements. Model performance will be evaluated to assess forecasting accuracy and differences in predictability across companies.

## Business Objectives
* Compare trend, seasonality, and volatility across AAPL, MSFT, TSLA, and AMZN.
* Forecast short-term price movements using multiple models.
* Evaluate models using time-series appropriate validation and accuracy metrics.
* Rank stocks by forecastability (which stock is easier/harder to predict).

## Success Criteria
* Clean daily dataset per stock with aligned calendars.
* Baseline model + at least one statistical forecasting model per stock.
* Residual diagnostics + accuracy metrics (RMSE/MAE/MAPE).
* Clear comparative summary and recommendation.


\newpage
# **Data Understanding**
## Data Source
Historical stock price data for Apple (AAPL), Microsoft (MSFT), Tesla (TSLA), and Amazon (AMZN) will be sourced from Yahoo Finance using the `quantmod` package in R. The dataset will include daily adjusted closing prices, volume, and other relevant financial metrics from January 1, 2016, to current date.

## Stock Tickers
* Apple Inc. (AAPL)
* Microsoft Corporation (MSFT)
* Tesla, Inc. (TSLA)
* Amazon.com, Inc. (AMZN)

```{r data-fetching}
# Define stock tickers and date range
tickers <- c("AAPL", "MSFT", "TSLA", "AMZN")
start_date <- as.Date("2016-01-01")
end_date <- as.Date("2026-01-20")
```

## Pull Historical Prices
```{r data-pulling}
prices_list <- map(
  tickers,
  ~ getSymbols(
    .x,
    src = "yahoo",
    from = start_date,
    to = end_date,
    auto.assign = FALSE
  )
)
names(prices_list) <- tickers

# Preview data
map(prices_list, head)
map(prices_list, tail)
```

## Extract Adjusted Close Prices
```{r adjusted-close}
close_list <- map(prices_list, ~ Cl(.x))
names(close_list) <- tickers

# Combine into a single xts with aligned dates
close_xts <- do.call(merge, close_list)
colnames(close_xts) <- tickers

head(close_xts)
tail(close_xts)
```

## Missing Dates / Alignment
Markets close on weekends/holidays; we keep the market calendar as-is.
```{r missing-dates}
close_xts_aligned <- na.omit(close_xts)
dim(close_xts); dim(close_xts_aligned)
```


\newpage
# **Data Preparation**
## Convert to Tidy Data
```{r tidy-data}
close_df <- close_xts_aligned %>%
  fortify.zoo() %>%
  as_tibble() %>%
  rename(date = Index) %>%
  pivot_longer(-date, names_to = "ticker", values_to = "close")

glimpse(close_df)
```

## Create Returns (Risk/Volatility Lens)
Returns analysis is essential for risk assessment.
```{r returns-calculation}
returns_xts <- na.omit(Return.calculate(close_xts_aligned, method = "log"))
colnames(returns_xts) <- tickers

returns_df <- returns_xts %>%
  fortify.zoo() %>%
  as_tibble() %>%
  rename(date = Index) %>%
  pivot_longer(-date, names_to = "ticker", values_to = "log_return")

summary(returns_df$log_return)
```


\newpage
# **Exploratory Data Analysis (EDA)**
## Price Trends
```{r price-trends}
close_df %>%
  ggplot(aes(date, close, color = ticker)) +
  geom_line() +
  labs(
    title = "Closing Prices Over Time (AAPL, MSFT, TSLA, AMZN)",
    x = "Date", y = "Close Price (USD)"
  )
```

## Normalize Prices (Indexed to 100)
```{r normalized-prices}
close_indexed <- close_df %>%
  group_by(ticker) %>%
  arrange(date) %>%
  mutate(index_100 = 100 * close / first(close)) %>%
  ungroup()

close_indexed %>%
  ggplot(aes(date, index_100, color = ticker)) +
  geom_line() +
  labs(
    title = "Indexed Closing Prices (Start = 100)",
    x = "Date", y = "Index"
  )
```

## Return & Drawdown Summary
```{r returns-drawdown}
charts.PerformanceSummary(
  returns_xts,
  main = "Performance Summary: Daily Log Returns (All Stocks)")
```

## Volatility Comparison (Rolling Std. Dev.)
```{r volatility-comparison}
roll_n <- 20 # ~1 trading month
roll_vol <- rollapply(returns_xts, 
                      width = roll_n, 
                      FUN = sd, 
                      by.column = TRUE, 
                      align = "right", 
                      fill = NA) %>%
  na.omit()

roll_vol_df <- roll_vol %>%
  fortify.zoo() %>%
  as_tibble() %>%
  rename(date = Index) %>%
  pivot_longer(-date, 
               names_to = "ticker", 
               values_to = "roll_sd")

roll_vol_df %>%
  ggplot(aes(date, roll_sd, color = ticker)) +
  geom_line() +
  labs(
    title = glue::glue("Rolling Volatility (Std Dev of Returns) - {roll_n} Trading Days"),
    x = "Date", 
    y = "Rolling SD"
  )
```

## Decomposition (Monthly Aggregation)
Classic decomposition is easiest on regular seasonal frequency.
We convert daily close to monthly close and decompose per stock.

```{r decomposition}
monthly_close_list <- map(close_list, ~ Cl(to.monthly(.x)) )
names(monthly_close_list) <- tickers

decomp_plots <- function(x_xts, ticker_name){
  ts_obj <- ts(
    as.numeric(x_xts), 
    frequency = 12,
    start = c(year(start(x_xts)), month(start(x_xts)))
    )
  dc <- decompose(ts_obj)
  plot(dc)
  title(main = paste("Decomposition:", ticker_name),
        outer = TRUE, line = -1)
  invisible(dc)
}

# Decompose each ticker (plots)
decomps <- imap(monthly_close_list, ~ decomp_plots(.x, .y))
```


\newpage
# **Modeling**
## Forecasting Design
We’ll forecast short-term movement using:

* Naive baseline (last value persists) - strong baseline in finance.
* ARIMA (auto.arima) - standard statistical model for time series. 

We’ll do a rolling-origin evaluation (time-series CV) AND a simple holdout for interpretability.

## Helper Functions
```{r helper-functions}
make_train_test <- function(x, h = 60){
  # x is a numeric vector or ts; h is forecast horizon
  n <- length(x)
  list(train = x[1:(n-h)], test = x[(n-h+1):n], h = h)
}

rmse <- function(actual, pred){
  sqrt(mean((actual - pred)^2, na.rm = TRUE))
}

mae <- function(actual, pred){
  mean(abs(actual - pred), na.rm = TRUE)
}

mape <- function(actual, pred){
  mean(abs((actual - pred) / actual), na.rm = TRUE) * 100
}
```

## Build Models per Stock
```{r modeling}
h <- 60  # forecast horizon ~ 3 months of trading days

results <- map_dfr(tickers, function(tk){
  x <- as.numeric(close_xts_aligned[, tk])
  spl <- make_train_test(x, h = h)
  train <- spl$train
  test  <- spl$test
  
  # --- Naive baseline ---
  fc_naive <- naive(train, h = h)
  pred_naive <- as.numeric(fc_naive$mean)
  
  # --- ARIMA ---
  fit_arima <- auto.arima(train)
  fc_arima <- forecast(fit_arima, h = h)
  pred_arima <- as.numeric(fc_arima$mean)
  
  tibble(
    ticker = tk,
    model  = c("Naive", "ARIMA"),
    RMSE   = c(rmse(test, pred_naive), rmse(test, pred_arima)),
    MAE    = c(mae(test, pred_naive),  mae(test, pred_arima)),
    MAPE   = c(mape(test, pred_naive), mape(test, pred_arima))
  )
})

results %>% arrange(ticker, RMSE)
```

## Visualize Forecasts vs Actuals per Stock
```{r forecast-visualization}
plot_forecast <- function(tk){
  x <- as.numeric(close_xts_aligned[, tk])
  spl <- make_train_test(x, h = h)
  train <- spl$train
  test  <- spl$test
  
  fc_naive <- naive(train, h = h)
  fit_arima <- auto.arima(train)
  fc_arima <- forecast(fit_arima, h = h)
  
  # Plot ARIMA by default; overlay actual test
  autoplot(fc_arima) +
    autolayer(ts(test, start = length(train) + 1), 
              series = "Actual (Test)") +
    labs(title = paste("ARIMA Forecast vs Actual:", tk), 
         x = "Time Index", y = "Close") 
}

walk(tickers, ~ print(plot_forecast(.x)))
```


\newpage
# **Evaluation**
## Accuracy Leaderboard (Model Comparison)
Forecast Accuracy by Stock and Model (Lower RMSE/MAE/MAPE is Better)
```{r accuracy-leaderboard}
results %>%
  group_by(ticker) %>%
  arrange(RMSE, .by_group = TRUE) %>%
  mutate(rank = row_number()) %>%
  ungroup() %>%
  arrange(ticker, rank) %>%
  knitr::kable(digits = 3, 
               caption = "Forecast Accuracy by Stock and Model")
```

## Best Model per Stock
```{r best-models}
best_by_stock <- results %>%
  group_by(ticker) %>%
  slice_min(RMSE, n = 1, with_ties = FALSE) %>%
  ungroup()

best_by_stock %>% knitr::kable(digits = 3, 
                               caption = "Best Model Per Stock (by RMSE)")
```

## Residual Diagnostics for Best Models
We check residuals to see if assumptions look reasonable (ACF, histogram, Ljung-Box)
```{r residual-diagnostics}
check_best_residuals <- function(tk){
  x <- as.numeric(close_xts_aligned[, tk])
  spl <- make_train_test(x, h = h)
  train <- spl$train
  
  fit_arima <- auto.arima(train)
  fc_arima <- forecast(fit_arima, h = h)
  
  cat("\n\n### Residual checks for", tk, "\n")
  print(fit_arima)
  checkresiduals(fc_arima)
}

walk(best_by_stock$ticker, check_best_residuals)
```

## Comparative Interpretation
Comparative Forecastability (Lower RMSE = More Predictable)
```{r comparative-interpretation}
# Stock that is easiest/hardest to forecast (based on best RMSE)
forecastability_tbl <- best_by_stock %>%
  arrange(RMSE) %>%
  mutate(forecastability_rank = row_number())

forecastability_tbl %>%
  knitr::kable(digits = 3, 
               caption = "Comparative Forecastability of Stocks")
```


\newpage
# **Deployment**
## Reproducible Forecast Function
A simple deployment-ready function that can be reused in a script, Shiny app, or scheduled job.
```{r deploy-function}
forecast_stock <- function(ticker, from = start_date, to = end_date, h = 20){
  x <- getSymbols(ticker, src = "yahoo", from = from, to = to, auto.assign = FALSE)
  close <- as.numeric(Cl(x))
  
  fit <- auto.arima(close)
  fc  <- forecast(fit, h = h)
  
  list(
    ticker = ticker,
    model  = fit,
    forecast = fc
  )
}

# Example:
demo <- forecast_stock("AAPL", from = start_date, to = end_date, h = 20)
autoplot(demo$forecast) + labs(title = "Deployment Demo: AAPL 20-Day Forecast")
```


\newpage
# **Conclusion**
## Key Findings
* Trend & growth differed meaningfully across AAPL/MSFT/TSLA/AMZN.
* Volatility (rolling SD of returns) highlighted different risk regimes—typically TSLA exhibits higher volatility.
* Naive baseline is a strong benchmark; any model must beat it to justify complexity. 
* ARIMA often improves on naive for some tickers, but not always—evaluation determines the winner.

## Next Improvement
* Explore additional models (e.g., ETS, Prophet, machine learning).
* Incorporate exogenous variables (e.g., market indices, macroeconomic indicators).
* Extend forecast horizon and evaluate longer-term predictability.
* Automate regular updates and forecasts via scheduled scripts or dashboards.


\newpage
# **References**
* Hyndman, R. J., & Athanasopoulos, G. (2018). *Forecasting: principles and practice*. OTexts.
* Yahoo Finance. (n.d.). Retrieved from https://finance.yahoo.com/
* R Documentation for `quantmod`, `forecast`, and `tseries` packages.


\newpage
\thispagestyle{plain}
\vspace*{\fill}
\begin{center}
\textbf{\Huge Thank You!}
\end{center}
\vspace*{\fill}
